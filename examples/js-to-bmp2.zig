// Port of js-to-bmp.c to Zig.

const INPUT_CAP: usize = 65536;
const OUTPUT_CAP: usize = 8 * 1024 * 1024;
const GLYPH_W: u32 = 8;
const GLYPH_H: u32 = 8;
const LEADING: u32 = 4;
const ROW_H: u32 = GLYPH_H + LEADING;
const COLS: u32 = 80;

var input_buf: [INPUT_CAP]u8 = undefined;
var output_buf: [OUTPUT_CAP]u8 = undefined;

export fn input_ptr() u32 {
    return @as(u32, @intCast(@intFromPtr(&input_buf)));
}

export fn input_utf8_cap() u32 {
    return @as(u32, @intCast(INPUT_CAP));
}

export fn output_ptr() u32 {
    return @as(u32, @intCast(@intFromPtr(&output_buf)));
}

export fn output_bytes_cap() u32 {
    return @as(u32, @intCast(OUTPUT_CAP));
}

const Color = struct {
    r: u8,
    g: u8,
    b: u8,
    a: u8,
};

fn writeU16LE(off: u32, value: u16) void {
    const idx: usize = @intCast(off);
    output_buf[idx] = @intCast(value & 0xFF);
    output_buf[idx + 1] = @intCast((value >> 8) & 0xFF);
}

fn writeU32LE(off: u32, value: u32) void {
    const idx: usize = @intCast(off);
    output_buf[idx] = @intCast(value & 0xFF);
    output_buf[idx + 1] = @intCast((value >> 8) & 0xFF);
    output_buf[idx + 2] = @intCast((value >> 16) & 0xFF);
    output_buf[idx + 3] = @intCast((value >> 24) & 0xFF);
}

fn setPixel(width: u32, height: u32, x: u32, y: u32, c: Color) void {
    if (x >= width or y >= height) return;
    const row: u32 = height - 1 - y;
    const idx: usize = @intCast(54 + (row * width + x) * 4);
    output_buf[idx] = c.b;
    output_buf[idx + 1] = c.g;
    output_buf[idx + 2] = c.r;
    output_buf[idx + 3] = c.a;
}

// Public domain font data from https://github.com/dhepper/font8x8
const font8x8_basic = [_][8]u8{
    .{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },
    .{ 0x7E,0x81,0xA5,0x81,0xBD,0x99,0x81,0x7E },
    .{ 0x7E,0xFF,0xDB,0xFF,0xC3,0xE7,0xFF,0x7E },
    .{ 0x6C,0xFE,0xFE,0xFE,0x7C,0x38,0x10,0x00 },
    .{ 0x10,0x38,0x7C,0xFE,0x7C,0x38,0x10,0x00 },
    .{ 0x38,0x7C,0x38,0xFE,0xFE,0xD6,0x10,0x38 },
    .{ 0x10,0x38,0x7C,0xFE,0xFE,0x7C,0x10,0x38 },
    .{ 0x00,0x00,0x18,0x3C,0x3C,0x18,0x00,0x00 },
    .{ 0xFF,0xFF,0xE7,0xC3,0xC3,0xE7,0xFF,0xFF },
    .{ 0x00,0x3C,0x66,0x42,0x42,0x66,0x3C,0x00 },
    .{ 0xFF,0xC3,0x99,0xBD,0xBD,0x99,0xC3,0xFF },
    .{ 0x0F,0x07,0x0F,0x7D,0xCC,0xCC,0xCC,0x78 },
    .{ 0x3C,0x66,0x66,0x66,0x3C,0x18,0x7E,0x18 },
    .{ 0x3F,0x33,0x3F,0x30,0x30,0x70,0xF0,0xE0 },
    .{ 0x7F,0x63,0x7F,0x63,0x63,0x67,0xE6,0xC0 },
    .{ 0x99,0x5A,0x3C,0xE7,0xE7,0x3C,0x5A,0x99 },
    .{ 0x80,0xE0,0xF8,0xFE,0xF8,0xE0,0x80,0x00 },
    .{ 0x02,0x0E,0x3E,0xFE,0x3E,0x0E,0x02,0x00 },
    .{ 0x18,0x3C,0x7E,0x18,0x18,0x7E,0x3C,0x18 },
    .{ 0x66,0x66,0x66,0x66,0x66,0x00,0x66,0x00 },
    .{ 0x7F,0xDB,0xDB,0x7B,0x1B,0x1B,0x1B,0x00 },
    .{ 0x3E,0x61,0x3C,0x66,0x66,0x3C,0x86,0x7C },
    .{ 0x00,0x00,0x00,0x00,0x7E,0x7E,0x7E,0x00 },
    .{ 0x18,0x3C,0x7E,0x18,0x7E,0x3C,0x18,0xFF },
    .{ 0x18,0x3C,0x7E,0x18,0x18,0x18,0x18,0x00 },
    .{ 0x18,0x18,0x18,0x18,0x7E,0x3C,0x18,0x00 },
    .{ 0x00,0x18,0x0C,0xFE,0x0C,0x18,0x00,0x00 },
    .{ 0x00,0x30,0x60,0xFE,0x60,0x30,0x00,0x00 },
    .{ 0x00,0x00,0xC0,0xC0,0xC0,0xFE,0x00,0x00 },
    .{ 0x00,0x24,0x66,0xFF,0x66,0x24,0x00,0x00 },
    .{ 0x00,0x18,0x3C,0x7E,0xFF,0xFF,0x00,0x00 },
    .{ 0x00,0xFF,0xFF,0x7E,0x3C,0x18,0x00,0x00 },
    .{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },
    .{ 0x18,0x3C,0x3C,0x18,0x18,0x00,0x18,0x00 },
    .{ 0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00 },
    .{ 0x66,0x66,0xFF,0x66,0xFF,0x66,0x66,0x00 },
    .{ 0x18,0x3E,0x60,0x3C,0x06,0x7C,0x18,0x00 },
    .{ 0x00,0xC6,0xCC,0x18,0x30,0x66,0xC6,0x00 },
    .{ 0x38,0x6C,0x38,0x76,0xDC,0xCC,0x76,0x00 },
    .{ 0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00 },
    .{ 0x0C,0x18,0x30,0x30,0x30,0x18,0x0C,0x00 },
    .{ 0x30,0x18,0x0C,0x0C,0x0C,0x18,0x30,0x00 },
    .{ 0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00 },
    .{ 0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00 },
    .{ 0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x30 },
    .{ 0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00 },
    .{ 0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00 },
    .{ 0x06,0x0C,0x18,0x30,0x60,0xC0,0x80,0x00 },
    .{ 0x7C,0xC6,0xCE,0xD6,0xE6,0xC6,0x7C,0x00 },
    .{ 0x18,0x38,0x18,0x18,0x18,0x18,0x7E,0x00 },
    .{ 0x7C,0xC6,0x0E,0x1C,0x70,0xC0,0xFE,0x00 },
    .{ 0x7C,0xC6,0x06,0x3C,0x06,0xC6,0x7C,0x00 },
    .{ 0x1C,0x3C,0x6C,0xCC,0xFE,0x0C,0x1E,0x00 },
    .{ 0xFE,0xC0,0xFC,0x06,0x06,0xC6,0x7C,0x00 },
    .{ 0x3C,0x60,0xC0,0xFC,0xC6,0xC6,0x7C,0x00 },
    .{ 0xFE,0xC6,0x0C,0x18,0x30,0x30,0x30,0x00 },
    .{ 0x7C,0xC6,0xC6,0x7C,0xC6,0xC6,0x7C,0x00 },
    .{ 0x7C,0xC6,0xC6,0x7E,0x06,0x0C,0x78,0x00 },
    .{ 0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00 },
    .{ 0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x30 },
    .{ 0x0E,0x1C,0x38,0x70,0x38,0x1C,0x0E,0x00 },
    .{ 0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00 },
    .{ 0x70,0x38,0x1C,0x0E,0x1C,0x38,0x70,0x00 },
    .{ 0x7C,0xC6,0x0E,0x1C,0x18,0x00,0x18,0x00 },
    .{ 0x7C,0xC6,0xDE,0xDE,0xDE,0xC0,0x78,0x00 },
    .{ 0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0x00 },
    .{ 0xFC,0x66,0x66,0x7C,0x66,0x66,0xFC,0x00 },
    .{ 0x3C,0x66,0xC0,0xC0,0xC0,0x66,0x3C,0x00 },
    .{ 0xF8,0x6C,0x66,0x66,0x66,0x6C,0xF8,0x00 },
    .{ 0xFE,0x62,0x68,0x78,0x68,0x62,0xFE,0x00 },
    .{ 0xFE,0x62,0x68,0x78,0x68,0x60,0xF0,0x00 },
    .{ 0x3C,0x66,0xC0,0xC0,0xCE,0x66,0x3E,0x00 },
    .{ 0xC6,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0x00 },
    .{ 0x3C,0x18,0x18,0x18,0x18,0x18,0x3C,0x00 },
    .{ 0x1E,0x0C,0x0C,0x0C,0xCC,0xCC,0x78,0x00 },
    .{ 0xE6,0x66,0x6C,0x78,0x6C,0x66,0xE6,0x00 },
    .{ 0xF0,0x60,0x60,0x60,0x62,0x66,0xFE,0x00 },
    .{ 0xC6,0xEE,0xFE,0xFE,0xD6,0xC6,0xC6,0x00 },
    .{ 0xC6,0xE6,0xF6,0xDE,0xCE,0xC6,0xC6,0x00 },
    .{ 0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00 },
    .{ 0xFC,0x66,0x66,0x7C,0x60,0x60,0xF0,0x00 },
    .{ 0x7C,0xC6,0xC6,0xC6,0xD6,0xCC,0x7A,0x00 },
    .{ 0xFC,0x66,0x66,0x7C,0x6C,0x66,0xE6,0x00 },
    .{ 0x7C,0xC6,0x60,0x38,0x0C,0xC6,0x7C,0x00 },
    .{ 0x7E,0x7E,0x5A,0x18,0x18,0x18,0x3C,0x00 },
    .{ 0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00 },
    .{ 0xC6,0xC6,0xC6,0xC6,0xC6,0x6C,0x38,0x00 },
    .{ 0xC6,0xC6,0xC6,0xD6,0xFE,0xEE,0xC6,0x00 },
    .{ 0xC6,0xC6,0x6C,0x38,0x38,0x6C,0xC6,0x00 },
    .{ 0x66,0x66,0x66,0x3C,0x18,0x18,0x3C,0x00 },
    .{ 0xFE,0xC6,0x8C,0x18,0x32,0x66,0xFE,0x00 },
    .{ 0x3C,0x30,0x30,0x30,0x30,0x30,0x3C,0x00 },
    .{ 0xC0,0x60,0x30,0x18,0x0C,0x06,0x02,0x00 },
    .{ 0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00 },
    .{ 0x10,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00 },
    .{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF },
    .{ 0x30,0x18,0x0C,0x00,0x00,0x00,0x00,0x00 },
    .{ 0x00,0x00,0x7C,0x06,0x7E,0xC6,0x7E,0x00 },
    .{ 0xE0,0x60,0x7C,0x66,0x66,0x66,0xDC,0x00 },
    .{ 0x00,0x00,0x7C,0xC6,0xC0,0xC6,0x7C,0x00 },
    .{ 0x1C,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00 },
    .{ 0x00,0x00,0x7C,0xC6,0xFE,0xC0,0x7C,0x00 },
    .{ 0x3C,0x66,0x60,0xF8,0x60,0x60,0xF0,0x00 },
    .{ 0x00,0x00,0x76,0xCC,0xCC,0x7C,0x0C,0xF8 },
    .{ 0xE0,0x60,0x6C,0x76,0x66,0x66,0xE6,0x00 },
    .{ 0x18,0x00,0x38,0x18,0x18,0x18,0x3C,0x00 },
    .{ 0x0C,0x00,0x1C,0x0C,0x0C,0xCC,0xCC,0x78 },
    .{ 0xE0,0x60,0x66,0x6C,0x78,0x6C,0xE6,0x00 },
    .{ 0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00 },
    .{ 0x00,0x00,0xEC,0xFE,0xD6,0xD6,0xC6,0x00 },
    .{ 0x00,0x00,0xDC,0x66,0x66,0x66,0x66,0x00 },
    .{ 0x00,0x00,0x7C,0xC6,0xC6,0xC6,0x7C,0x00 },
    .{ 0x00,0x00,0xDC,0x66,0x66,0x7C,0x60,0xF0 },
    .{ 0x00,0x00,0x76,0xCC,0xCC,0x7C,0x0C,0x1E },
    .{ 0x00,0x00,0xDC,0x76,0x66,0x60,0xF0,0x00 },
    .{ 0x00,0x00,0x7E,0xC0,0x7C,0x06,0xFC,0x00 },
    .{ 0x30,0x30,0xFC,0x30,0x30,0x36,0x1C,0x00 },
    .{ 0x00,0x00,0xCC,0xCC,0xCC,0xCC,0x76,0x00 },
    .{ 0x00,0x00,0xC6,0xC6,0xC6,0x6C,0x38,0x00 },
    .{ 0x00,0x00,0xC6,0xD6,0xD6,0xFE,0x6C,0x00 },
    .{ 0x00,0x00,0xC6,0x6C,0x38,0x6C,0xC6,0x00 },
    .{ 0x00,0x00,0xC6,0xC6,0xC6,0x7E,0x06,0xFC },
    .{ 0x00,0x00,0xFE,0x4C,0x18,0x32,0xFE,0x00 },
    .{ 0x0E,0x18,0x18,0x70,0x18,0x18,0x0E,0x00 },
    .{ 0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x00 },
    .{ 0x70,0x18,0x18,0x0E,0x18,0x18,0x70,0x00 },
    .{ 0x76,0xDC,0x00,0x00,0x00,0x00,0x00,0x00 },
    .{ 0x00,0x10,0x38,0x6C,0xC6,0xC6,0xFE,0x00 }
};

fn countRows(input_size: u32) u32 {
    var rows: u32 = 1;
    var col: u32 = 0;
    var i: u32 = 0;
    while (i < input_size) {
        const c = input_buf[@intCast(i)];
        if (c == '\r') {
            if (i + 1 < input_size and input_buf[@intCast(i + 1)] == '\n') {
                i += 1;
            }
            rows += 1;
            col = 0;
            i += 1;
            continue;
        }
        if (c == '\n') {
            rows += 1;
            col = 0;
            i += 1;
            continue;
        }
        if (c == '\t') {
            const spaces = 4 - (col % 4);
            col += spaces;
            while (col >= COLS) {
                rows += 1;
                col = 0;
            }
            i += 1;
            continue;
        }
        col += 1;
        if (col >= COLS) {
            rows += 1;
            col = 0;
        }
        i += 1;
    }
    return rows;
}

fn isAlpha(c: u8) bool {
    return (c >= 'A' and c <= 'Z') or (c >= 'a' and c <= 'z');
}

fn isDigit(c: u8) bool {
    return c >= '0' and c <= '9';
}

fn isIdentStart(c: u8) bool {
    return isAlpha(c) or c == '_' or c == '$';
}

fn isIdentChar(c: u8) bool {
    return isIdentStart(c) or isDigit(c);
}

fn matchKw(start: u32, len: u32, kw: []const u8) bool {
    if (len != @as(u32, @intCast(kw.len))) return false;
    var i: u32 = 0;
    while (i < len) : (i += 1) {
        if (input_buf[@intCast(start + i)] != kw[@intCast(i)]) return false;
    }
    return true;
}

fn isKeyword(start: u32, len: u32) bool {
    return switch (len) {
        2 => matchKw(start, len, "if") or matchKw(start, len, "in") or
             matchKw(start, len, "do") or matchKw(start, len, "of"),
        3 => matchKw(start, len, "for") or matchKw(start, len, "var") or
             matchKw(start, len, "try") or matchKw(start, len, "new") or
             matchKw(start, len, "let"),
        4 => matchKw(start, len, "else") or matchKw(start, len, "this") or
             matchKw(start, len, "void") or matchKw(start, len, "with") or
             matchKw(start, len, "case"),
        5 => matchKw(start, len, "const") or matchKw(start, len, "while") or
             matchKw(start, len, "break") or matchKw(start, len, "catch") or
             matchKw(start, len, "class") or matchKw(start, len, "throw") or
             matchKw(start, len, "super") or matchKw(start, len, "async") or
             matchKw(start, len, "await") or matchKw(start, len, "yield"),
        6 => matchKw(start, len, "return") or matchKw(start, len, "typeof") or
             matchKw(start, len, "switch") or matchKw(start, len, "delete") or
             matchKw(start, len, "export") or matchKw(start, len, "import"),
        7 => matchKw(start, len, "default") or matchKw(start, len, "extends") or
             matchKw(start, len, "finally"),
        8 => matchKw(start, len, "function") or matchKw(start, len, "continue"),
        9 => matchKw(start, len, "instanceof"),
        10 => matchKw(start, len, "debugger"),
        else => false,
    };
}

fn drawGlyph(width: u32, height: u32, row: u32, col: u32, glyph_in: u8, color: Color) void {
    var glyph: u8 = glyph_in;
    if (glyph < 32 or glyph >= 128) glyph = '?';
    const base_x: u32 = col * GLYPH_W;
    const base_y: u32 = row * ROW_H;
    var gy: u32 = 0;
    while (gy < GLYPH_H) : (gy += 1) {
        const bits = font8x8_basic[glyph][@intCast(gy)];
        var gx: u32 = 0;
        while (gx < GLYPH_W) : (gx += 1) {
            if ((bits & (@as(u8, 1) << @intCast(7 - gx))) != 0) {
                setPixel(width, height, base_x + gx, base_y + gy, color);
            }
        }
    }
}

fn drawChar(width: u32, height: u32, row: *u32, col: *u32, rows: u32, glyph: u8, color: Color) void {
    if (row.* >= rows) return;
    drawGlyph(width, height, row.*, col.*, glyph, color);
    col.* += 1;
    if (col.* >= COLS) {
        row.* += 1;
        col.* = 0;
    }
}

export fn run(input_size_in: u32) u32 {
    var input_size = input_size_in;
    if (input_size > INPUT_CAP) input_size = @intCast(INPUT_CAP);

    const bg = Color{ .r = 0x16, .g = 0x1b, .b = 0x22, .a = 0xFF };
    const fg = Color{ .r = 0xc9, .g = 0xd1, .b = 0xd9, .a = 0xFF };
    const kw = Color{ .r = 0xff, .g = 0x7b, .b = 0x72, .a = 0xFF };
    const str = Color{ .r = 0xa5, .g = 0xd6, .b = 0xff, .a = 0xFF };
    const com = Color{ .r = 0x8b, .g = 0x94, .b = 0x9e, .a = 0xFF };
    const num = Color{ .r = 0x79, .g = 0xc0, .b = 0xff, .a = 0xFF };

    const rows = countRows(input_size);
    const width: u32 = COLS * GLYPH_W;
    const height: u32 = rows * ROW_H;
    const pixel_bytes: u64 = @as(u64, width) * @as(u64, height) * 4;
    const total: u64 = 54 + pixel_bytes;
    if (total > OUTPUT_CAP) return 0;
    const total_u32: u32 = @intCast(total);

    var i: u32 = 0;
    while (i < 54) : (i += 1) {
        output_buf[@intCast(i)] = 0;
    }
    i = 54;
    while (i < total_u32) : (i += 4) {
        const idx: usize = @intCast(i);
        output_buf[idx] = bg.b;
        output_buf[idx + 1] = bg.g;
        output_buf[idx + 2] = bg.r;
        output_buf[idx + 3] = bg.a;
    }

    output_buf[0] = 'B';
    output_buf[1] = 'M';
    writeU32LE(2, total_u32);
    writeU32LE(6, 0);
    writeU32LE(10, 54);
    writeU32LE(14, 40);
    writeU32LE(18, width);
    writeU32LE(22, height);
    writeU16LE(26, 1);
    writeU16LE(28, 32);
    writeU32LE(30, 0);
    writeU32LE(34, @intCast(pixel_bytes));
    writeU32LE(38, 2835);
    writeU32LE(42, 2835);
    writeU32LE(46, 0);
    writeU32LE(50, 0);

    var col: u32 = 0;
    var row: u32 = 0;
    i = 0;
    var in_string = false;
    var in_line_comment = false;
    var in_block_comment = false;
    var quote: u8 = 0;
    var escape = false;

    while (i < input_size and row < rows) {
        const c = input_buf[@intCast(i)];
        if (c == '\r' or c == '\n') {
            in_line_comment = false;
            if (c == '\r' and i + 1 < input_size and input_buf[@intCast(i + 1)] == '\n') {
                i += 1;
            }
            row += 1;
            col = 0;
            in_string = false;
            escape = false;
            i += 1;
            continue;
        }

        if (c == '\t') {
            const spaces = 4 - (col % 4);
            col += spaces;
            while (col >= COLS) {
                row += 1;
                col = 0;
                if (row >= rows) break;
            }
            i += 1;
            continue;
        }

        if (in_string) {
            drawChar(width, height, &row, &col, rows, c, str);
            if (escape) {
                escape = false;
            } else if (c == '\\') {
                escape = true;
            } else if (c == quote) {
                in_string = false;
            }
            i += 1;
            continue;
        }

        if (in_line_comment) {
            drawChar(width, height, &row, &col, rows, c, com);
            i += 1;
            continue;
        }

        if (in_block_comment) {
            if (c == '*' and i + 1 < input_size and input_buf[@intCast(i + 1)] == '/') {
                drawChar(width, height, &row, &col, rows, '*', com);
                drawChar(width, height, &row, &col, rows, '/', com);
                i += 2;
                in_block_comment = false;
                continue;
            }
            drawChar(width, height, &row, &col, rows, c, com);
            i += 1;
            continue;
        }

        if (c == '/' and i + 1 < input_size) {
            const next = input_buf[@intCast(i + 1)];
            if (next == '/') {
                drawChar(width, height, &row, &col, rows, '/', com);
                drawChar(width, height, &row, &col, rows, '/', com);
                i += 2;
                in_line_comment = true;
                continue;
            }
            if (next == '*') {
                drawChar(width, height, &row, &col, rows, '/', com);
                drawChar(width, height, &row, &col, rows, '*', com);
                i += 2;
                in_block_comment = true;
                continue;
            }
        }

        if (c == '\'' or c == '"' or c == '`') {
            in_string = true;
            quote = c;
            escape = false;
            drawChar(width, height, &row, &col, rows, c, str);
            i += 1;
            continue;
        }

        if (isDigit(c) or (c == '.' and i + 1 < input_size and isDigit(input_buf[@intCast(i + 1)]))) {
            const start = i;
            i += 1;
            while (i < input_size) {
                const nc = input_buf[@intCast(i)];
                if (isDigit(nc) or isAlpha(nc) or nc == '.' or nc == '_' or nc == '\'') {
                    i += 1;
                    continue;
                }
                if ((nc == '+' or nc == '-') and i > start) {
                    const prev = input_buf[@intCast(i - 1)];
                    if (prev == 'e' or prev == 'E' or prev == 'p' or prev == 'P') {
                        i += 1;
                        continue;
                    }
                }
                break;
            }
            const len = i - start;
            var j: u32 = 0;
            while (j < len) : (j += 1) {
                drawChar(width, height, &row, &col, rows, input_buf[@intCast(start + j)], num);
                if (row >= rows) break;
            }
            continue;
        }

        if (isIdentStart(c)) {
            const start = i;
            i += 1;
            while (i < input_size and isIdentChar(input_buf[@intCast(i)])) {
                i += 1;
            }
            const len = i - start;
            const color = if (isKeyword(start, len)) kw else fg;
            var j: u32 = 0;
            while (j < len) : (j += 1) {
                drawChar(width, height, &row, &col, rows, input_buf[@intCast(start + j)], color);
                if (row >= rows) break;
            }
            continue;
        }

        drawChar(width, height, &row, &col, rows, c, fg);
        i += 1;
    }

    return total_u32;
}
