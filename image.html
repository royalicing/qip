<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Image (WASM)</title>
    <style>
      :root {
        color-scheme: light;
      }
      body {
        font-family: system-ui, sans-serif;
        margin: 1lh;
        background: #111;
        color: white;
      }
      h1 {
        font-size: 20px;
        margin: 0 0 12px;
      }
      fieldset {
        border: none;
      }
      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
        margin-bottom: 16px;
      }
      .filters {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
      }
      .filter-row {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
        padding: 4px 0;
      }
      .filter-toggle-label {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }
      .drag-handle {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 18px;
        height: 18px;
        background: hsla(0, 0%, 100%, 0.1);
        color: white;
        font-size: 12px;
        cursor: grab;
        user-select: none;
      }
      .filter-row.dragging {
        opacity: 0.6;
      }
      .filter-menu {
        display: none;
        flex-direction: column;
        gap: 6px;
        padding: 12px;
        border: 1px solid #ddd;
        border-radius: 8px;
        background: #fff;
      }
      .filter-menu:popover-open {
        display: flex;
      }
      .filter-menu button {
        text-align: left;
        padding: 6px 8px;
        border: 1px solid #ddd;
        border-radius: 6px;
        background: #f7f7f7;
        cursor: pointer;
      }
      .divider {
        color: #888;
      }
      .canvases {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
      }
      canvas {
        --color: oklab(50% 0 0);
        width: 100%;
        height: auto;
        border: 1px solid var(--color);
        background: var(--color);
      }
      .label {
        font-size: 12px;
        color: #555;
        margin: 6px 0 4px;
      }
      #status {
        margin-top: 12px;
        font-size: 12px;
        color: #555;
      }
      @media (max-width: 800px) {
        .canvases {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <h1>Image (WASM)</h1>
    <div class="controls">
      <input id="file" type="file" accept="image/*" />
      <button type="button" popovertarget="filter-menu">Add filter</button>
    </div>

    <fieldset class="controls filters" id="filters"></fieldset>

    <div id="filter-menu" popover class="filter-menu">
      <button type="button" data-add-filter="brightness">Brightness</button>
      <button type="button" data-add-filter="contrast">Contrast</button>
      <button type="button" data-add-filter="saturation">Saturation</button>
      <button type="button" data-add-filter="hue-rotate">Hue rotate</button>
      <button type="button" data-add-filter="temperature">Temperature</button>
      <button type="button" data-add-filter="tint">Tint</button>
      <button type="button" data-add-filter="posterize">Posterize</button>
      <button type="button" data-add-filter="color-halftone">Color halftone</button>
      <button type="button" data-add-filter="gaussian-blur">Gaussian blur</button>
      <button type="button" data-add-filter="cutout">Cutout</button>
      <button type="button" data-add-filter="vignette">Vignette</button>
      <button type="button" data-add-filter="black-and-white">Black and white</button>
      <button type="button" data-add-filter="find-edges">Find edges</button>
      <button type="button" data-add-filter="invert">Invert</button>
    </div>

    <div class="canvases">
      <div>
        <div class="label">Original</div>
        <canvas id="source"></canvas>
      </div>
      <div>
        <div class="label">Result</div>
        <canvas id="output"></canvas>
      </div>
    </div>

    <div id="status">Loading WASM...</div>

    <template id="filter-template-brightness">
      <div class="filter-row" data-filter-id="brightness">
        <span class="drag-handle" draggable="true" aria-hidden="true">≡</span>
        <label class="filter-toggle-label">
          <input type="checkbox" class="filter-toggle" checked />
          <span>Brightness</span>
        </label>
        <input
          type="range"
          min="-1"
          max="1"
          step="0.01"
          value="0"
          data-uniform="uniform_set_brightness"
          data-format="fixed2"
        />
        <span data-value-for="uniform_set_brightness">0.00</span>
      </div>
    </template>

    <template id="filter-template-contrast">
      <div class="filter-row" data-filter-id="contrast">
        <span class="drag-handle" draggable="true" aria-hidden="true">≡</span>
        <label class="filter-toggle-label">
          <input type="checkbox" class="filter-toggle" checked />
          <span>Contrast</span>
        </label>
        <input
          type="range"
          min="-1"
          max="1"
          step="0.01"
          value="0"
          data-uniform="uniform_set_contrast"
          data-format="fixed2"
        />
        <span data-value-for="uniform_set_contrast">0.00</span>
      </div>
    </template>

    <template id="filter-template-saturation">
      <div class="filter-row" data-filter-id="saturation">
        <span class="drag-handle" draggable="true" aria-hidden="true">≡</span>
        <label class="filter-toggle-label">
          <input type="checkbox" class="filter-toggle" checked />
          <span>Saturation</span>
        </label>
        <input
          type="range"
          min="-1"
          max="1"
          step="0.01"
          value="0"
          data-uniform="uniform_set_saturation"
          data-format="fixed2"
        />
        <span data-value-for="uniform_set_saturation">0.00</span>
      </div>
    </template>

    <template id="filter-template-hue-rotate">
      <div class="filter-row" data-filter-id="hue-rotate">
        <span class="drag-handle" draggable="true" aria-hidden="true">≡</span>
        <label class="filter-toggle-label">
          <input type="checkbox" class="filter-toggle" checked />
          <span>Hue</span>
        </label>
        <input
          type="range"
          min="-180"
          max="180"
          step="1"
          value="0"
          data-uniform="uniform_set_hue_degrees"
          data-format="int"
        />
        <span data-value-for="uniform_set_hue_degrees">0</span>
      </div>
    </template>

    <template id="filter-template-temperature">
      <div class="filter-row" data-filter-id="temperature">
        <span class="drag-handle" draggable="true" aria-hidden="true">≡</span>
        <label class="filter-toggle-label">
          <input type="checkbox" class="filter-toggle" checked />
          <span>Temperature</span>
        </label>
        <input
          type="range"
          min="-1"
          max="1"
          step="0.01"
          value="0"
          data-uniform="uniform_set_temperature"
          data-format="fixed2"
        />
        <span data-value-for="uniform_set_temperature">0.00</span>
      </div>
    </template>

    <template id="filter-template-tint">
      <div class="filter-row" data-filter-id="tint">
        <span class="drag-handle" draggable="true" aria-hidden="true">≡</span>
        <label class="filter-toggle-label">
          <input type="checkbox" class="filter-toggle" checked />
          <span>Tint</span>
        </label>
        <input
          type="range"
          min="-1"
          max="1"
          step="0.01"
          value="0"
          data-uniform="uniform_set_tint"
          data-format="fixed2"
        />
        <span data-value-for="uniform_set_tint">0.00</span>
      </div>
    </template>

    <template id="filter-template-posterize">
      <div class="filter-row" data-filter-id="posterize">
        <span class="drag-handle" draggable="true" aria-hidden="true">≡</span>
        <label class="filter-toggle-label">
          <input type="checkbox" class="filter-toggle" />
          <span>Posterize</span>
        </label>
        <input
          type="range"
          min="2"
          max="32"
          value="8"
          data-uniform="uniform_set_levels_count"
          data-format="int"
        />
        <span data-value-for="uniform_set_levels_count">8</span>
      </div>
    </template>

    <template id="filter-template-color-halftone">
      <div class="filter-row" data-filter-id="color-halftone">
        <span class="drag-handle" draggable="true" aria-hidden="true">≡</span>
        <label class="filter-toggle-label">
          <input type="checkbox" class="filter-toggle" />
          <span>Color halftone</span>
        </label>
        <span class="divider">|</span>
        <span>Max radius:</span>
        <input
          type="range"
          min="1"
          max="24"
          step="1"
          value="6"
          data-uniform="uniform_set_max_radius"
          data-format="int"
        />
        <span data-value-for="uniform_set_max_radius">6</span>
        <span class="divider">|</span>
        <span>Angle C:</span>
        <input
          type="range"
          min="-180"
          max="180"
          step="1"
          value="15"
          data-uniform="uniform_set_angle_c"
          data-format="int"
        />
        <span data-value-for="uniform_set_angle_c">15</span>
        <span class="divider">|</span>
        <span>Angle M:</span>
        <input
          type="range"
          min="-180"
          max="180"
          step="1"
          value="75"
          data-uniform="uniform_set_angle_m"
          data-format="int"
        />
        <span data-value-for="uniform_set_angle_m">75</span>
        <span class="divider">|</span>
        <span>Angle Y:</span>
        <input
          type="range"
          min="-180"
          max="180"
          step="1"
          value="0"
          data-uniform="uniform_set_angle_y"
          data-format="int"
        />
        <span data-value-for="uniform_set_angle_y">0</span>
        <span class="divider">|</span>
        <span>Angle K:</span>
        <input
          type="range"
          min="-180"
          max="180"
          step="1"
          value="45"
          data-uniform="uniform_set_angle_k"
          data-format="int"
        />
        <span data-value-for="uniform_set_angle_k">45</span>
      </div>
    </template>

    <template id="filter-template-gaussian-blur">
      <div class="filter-row" data-filter-id="gaussian-blur">
        <span class="drag-handle" draggable="true" aria-hidden="true">≡</span>
        <label class="filter-toggle-label">
          <input type="checkbox" class="filter-toggle" />
          <span>Gaussian blur</span>
        </label>
        <span class="divider">|</span>
        <span>Radius:</span>
        <input
          type="range"
          min="0"
          max="12"
          step="1"
          value="2"
          data-uniform="uniform_set_radius"
          data-format="int"
        />
        <span data-value-for="uniform_set_radius">2</span>
      </div>
    </template>

    <template id="filter-template-cutout">
      <div class="filter-row" data-filter-id="cutout">
        <span class="drag-handle" draggable="true" aria-hidden="true">≡</span>
        <label class="filter-toggle-label">
          <input type="checkbox" class="filter-toggle" />
          <span>Cutout</span>
        </label>
        <span class="divider">|</span>
        <span>Levels:</span>
        <input
          type="range"
          min="2"
          max="12"
          step="1"
          value="4"
          data-uniform="uniform_set_levels"
          data-format="int"
        />
        <span data-value-for="uniform_set_levels">4</span>
        <span class="divider">|</span>
        <span>Edge threshold:</span>
        <input
          type="range"
          min="0"
          max="1"
          step="0.01"
          value="0.25"
          data-uniform="uniform_set_edge_threshold"
          data-format="fixed2"
        />
        <span data-value-for="uniform_set_edge_threshold">0.25</span>
        <span class="divider">|</span>
        <span>Edge strength:</span>
        <input
          type="range"
          min="0"
          max="1"
          step="0.01"
          value="0.7"
          data-uniform="uniform_set_edge_strength"
          data-format="fixed2"
        />
        <span data-value-for="uniform_set_edge_strength">0.70</span>
      </div>
    </template>

    <template id="filter-template-vignette">
      <div class="filter-row" data-filter-id="vignette">
        <span class="drag-handle" draggable="true" aria-hidden="true">≡</span>
        <label class="filter-toggle-label">
          <input type="checkbox" class="filter-toggle" />
          <span>Vignette</span>
        </label>
        <span class="divider">|</span>
        <span>Amount:</span>
        <input
          type="range"
          min="0"
          max="1"
          step="0.01"
          value="0.35"
          data-uniform="uniform_set_amount"
          data-format="fixed2"
        />
        <span data-value-for="uniform_set_amount">0.35</span>
        <span class="divider">|</span>
        <span>Midpoint:</span>
        <input
          type="range"
          min="0"
          max="1"
          step="0.01"
          value="0.65"
          data-uniform="uniform_set_midpoint"
          data-format="fixed2"
        />
        <span data-value-for="uniform_set_midpoint">0.65</span>
        <span class="divider">|</span>
        <span>Feather:</span>
        <input
          type="range"
          min="0"
          max="1"
          step="0.01"
          value="0.85"
          data-uniform="uniform_set_feather"
          data-format="fixed2"
        />
        <span data-value-for="uniform_set_feather">0.85</span>
      </div>
    </template>

    <template id="filter-template-black-and-white">
      <div class="filter-row" data-filter-id="black-and-white">
        <span class="drag-handle" draggable="true" aria-hidden="true">≡</span>
        <label class="filter-toggle-label">
          <input type="checkbox" class="filter-toggle" />
          <span>Black and white</span>
        </label>
      </div>
    </template>

    <template id="filter-template-find-edges">
      <div class="filter-row" data-filter-id="find-edges">
        <span class="drag-handle" draggable="true" aria-hidden="true">≡</span>
        <label class="filter-toggle-label">
          <input type="checkbox" class="filter-toggle" />
          <span>Find edges</span>
        </label>
      </div>
    </template>

    <template id="filter-template-invert">
      <div class="filter-row" data-filter-id="invert">
        <span class="drag-handle" draggable="true" aria-hidden="true">≡</span>
        <label class="filter-toggle-label">
          <input type="checkbox" class="filter-toggle" />
          <span>Invert</span>
        </label>
      </div>
    </template>

    <script>
      const TILE = 64;
      const TILE_FLOATS = TILE * TILE * 4;
      const fileInput = document.getElementById("file");
      const filtersContainer = document.getElementById("filters");
      const filterMenu = document.getElementById("filter-menu");
      const statusEl = document.getElementById("status");
      const sourceCanvas = document.getElementById("source");
      const outputCanvas = document.getElementById("output");
      const sourceCtx = sourceCanvas.getContext("2d");
      const outputCtx = outputCanvas.getContext("2d");

      const FILTER_DEFS = [
        { id: "brightness", path: "examples/rgba/brightness.wasm" },
        { id: "contrast", path: "examples/rgba/contrast.wasm" },
        { id: "saturation", path: "examples/rgba/saturation.wasm" },
        { id: "hue-rotate", path: "examples/rgba/hue-rotate.wasm" },
        { id: "temperature", path: "examples/rgba/temperature.wasm" },
        { id: "tint", path: "examples/rgba/tint.wasm" },
        { id: "posterize", path: "examples/rgba/posterize.wasm" },
        { id: "color-halftone", path: "examples/rgba/color-halftone.wasm" },
        { id: "gaussian-blur", path: "examples/rgba/gaussian-blur.wasm" },
        { id: "cutout", path: "examples/rgba/cutout.wasm" },
        { id: "vignette", path: "examples/rgba/vignette.wasm" },
        { id: "black-and-white", path: "examples/rgba/black-and-white.wasm" },
        { id: "find-edges", path: "examples/rgba/find-edges.wasm" },
        { id: "invert", path: "examples/rgba/invert.wasm" },
      ];

      const DEFAULT_PIPELINE = [
        "brightness",
        "contrast",
        "saturation",
        "hue-rotate",
        "temperature",
        "tint",
      ];

      function filtersToURLSearchParams() {
        const q = new URLSearchParams();
        const rows = filtersContainer.querySelectorAll(".filter-row");
        for (const row of rows) {
          const id = row.dataset.filterId;
          if (!id) {
            continue;
          }
          const toggle = row.querySelector(".filter-toggle");
          if (toggle && !toggle.checked) {
            continue;
          }
          const inputs = row.querySelectorAll("input[data-uniform]");
          const values = Array.from(inputs).map((input) => input.value);
          q.append(id, values.join(","));
        }
        return q;
      }

      function updateFiltersFromLocationHash() {
        const params = new URLSearchParams(location.hash.slice(1));
        if ([...params.keys()].length === 0) {
          if (!hasBootstrappedDefaults) {
            hasBootstrappedDefaults = true;
            filtersContainer.replaceChildren(
              ...DEFAULT_PIPELINE.map((id) => createFilterRow(id, null, true)),
            );
            updateLocationHash();
          } else {
            filtersContainer.replaceChildren();
          }
          return;
        }
        const rows = [];
        for (const [id, raw] of params) {
          const values = raw ? raw.split(",") : [];
          const row = createFilterRow(id, values, true);
          if (row) {
            rows.push(row);
          }
        }
        filtersContainer.replaceChildren(...rows);
      }

      function updateLocationHash() {
        const next = filtersToURLSearchParams().toString();
        const nextHash = next ? "#" + next : "";
        if (location.hash !== nextHash) {
          location.hash = nextHash;
        }
      }

      const filters = {};
      for (const def of FILTER_DEFS) {
        filters[def.id] = {
          id: def.id,
          path: def.path,
          uniforms: {},
        };
      }

      function createFilterRow(id, values, forceEnabled) {
        const tpl = document.getElementById(`filter-template-${id}`);
        if (!tpl) {
          return null;
        }
        const row = tpl.content.firstElementChild.cloneNode(true);
        if (!row) {
          return null;
        }
        row.dataset.filterId = id;
        const toggle = row.querySelector(".filter-toggle");
        if (toggle && forceEnabled) {
          toggle.checked = true;
        }
        const inputs = row.querySelectorAll("input[data-uniform]");
        if (values && values.length > 0) {
          for (let i = 0; i < inputs.length; i++) {
            if (values[i] !== undefined) {
              inputs[i].value = values[i];
            }
          }
        }
        for (const input of inputs) {
          updateValueDisplay(input);
        }
        return row;
      }

      function getTemplateDefaultValues(id) {
        const tpl = document.getElementById(`filter-template-${id}`);
        if (!tpl) {
          return [];
        }
        const inputs = tpl.content.querySelectorAll("input[data-uniform]");
        return Array.from(inputs).map((input) => input.value);
      }

      let hasBootstrappedDefaults = false;
      updateFiltersFromLocationHash();

      function exportedValue(exp) {
        if (typeof exp === "function") {
          return exp();
        }
        if (exp instanceof WebAssembly.Global) {
          return exp.value;
        }
        return exp;
      }

      function clampByte(value) {
        if (value < 0) return 0;
        if (value > 255) return 255;
        return value;
      }

      async function loadWasm() {
        await Promise.all(Object.values(filters).map(loadFilter));
      }

      async function loadFilter(filter) {
        const response = await fetch(filter.path);
        if (!response.ok) {
          throw new Error("Failed to load " + filter.path);
        }
        const bytes = await response.arrayBuffer();
        const { instance } = await WebAssembly.instantiate(bytes, {});
        const exports = instance.exports;
        filter.exports = exports;
        filter.memory = exports.memory;
        filter.inputPtr = exportedValue(exports.input_ptr);
        filter.tileFn = exports.tile_rgba_f32_64x64;
        filter.uniformSetSize = exports.uniform_set_width_and_height || null;
        const possible = new Set();
        const tpl = document.getElementById(`filter-template-${filter.id}`);
        if (tpl) {
          const inputs = tpl.content.querySelectorAll("input[data-uniform]");
          for (const input of inputs) {
            if (input.dataset.uniform) {
              possible.add(input.dataset.uniform);
            }
          }
        }
        for (const name of possible) {
          filter.uniforms[name] = exports[name] || null;
        }
        filter.getTileView = () =>
          new Float32Array(filter.memory.buffer, filter.inputPtr, TILE_FLOATS);
      }

      function formatValue(input, value) {
        const format = input.dataset.format;
        if (format === "int") {
          return String(Math.round(value));
        }
        if (format === "fixed2") {
          return Number(value).toFixed(2);
        }
        const step = input.step || "";
        const decimals = step.includes(".") ? step.split(".")[1].length : 0;
        return decimals > 0 ? Number(value).toFixed(decimals) : String(value);
      }

      function updateValueDisplay(input) {
        const row = input.closest(".filter-row");
        if (!row) {
          return;
        }
        const uniformName = input.dataset.uniform;
        if (!uniformName) {
          return;
        }
        const value = Number(input.value);
        const valueEl = row.querySelector(
          `[data-value-for="${uniformName}"]`,
        );
        if (valueEl) {
          valueEl.textContent = formatValue(input, value);
        }
      }

      function processImageData(imageData, stages) {
        const { data, width, height } = imageData;
        const out = new Uint8ClampedArray(data.length);
        const tileBuffer = new Float32Array(TILE_FLOATS);

        for (let y = 0; y < height; y += TILE) {
          for (let x = 0; x < width; x += TILE) {
            tileBuffer.fill(0);
            const tileW = Math.min(TILE, width - x);
            const tileH = Math.min(TILE, height - y);

            for (let ty = 0; ty < tileH; ty++) {
              for (let tx = 0; tx < tileW; tx++) {
                const srcIndex = ((y + ty) * width + (x + tx)) * 4;
                const tileIndex = (ty * TILE + tx) * 4;
                tileBuffer[tileIndex] = data[srcIndex] / 255;
                tileBuffer[tileIndex + 1] = data[srcIndex + 1] / 255;
                tileBuffer[tileIndex + 2] = data[srcIndex + 2] / 255;
                tileBuffer[tileIndex + 3] = data[srcIndex + 3] / 255;
              }
            }

            runPipeline(tileBuffer, x, y, stages);

            for (let ty = 0; ty < tileH; ty++) {
              for (let tx = 0; tx < tileW; tx++) {
                const dstIndex = ((y + ty) * width + (x + tx)) * 4;
                const tileIndex = (ty * TILE + tx) * 4;
                out[dstIndex] = clampByte(
                  Math.round(tileBuffer[tileIndex] * 255),
                );
                out[dstIndex + 1] = clampByte(
                  Math.round(tileBuffer[tileIndex + 1] * 255),
                );
                out[dstIndex + 2] = clampByte(
                  Math.round(tileBuffer[tileIndex + 2] * 255),
                );
                out[dstIndex + 3] = clampByte(
                  Math.round(tileBuffer[tileIndex + 3] * 255),
                );
              }
            }
          }
        }

        return new ImageData(out, width, height);
      }

      let cachedImageData = null;

      async function handleFile(file) {
        statusEl.textContent = "Decoding image...";
        const bitmap = await createImageBitmap(file);
        sourceCanvas.width = bitmap.width;
        sourceCanvas.height = bitmap.height;
        outputCanvas.width = bitmap.width;
        outputCanvas.height = bitmap.height;
        sourceCtx.drawImage(bitmap, 0, 0);

        cachedImageData = sourceCtx.getImageData(
          0,
          0,
          bitmap.width,
          bitmap.height,
        );
        setImageSize(bitmap.width, bitmap.height);
        renderPosterized();
      }

      function renderPosterized() {
        if (!cachedImageData) {
          return;
        }
        statusEl.textContent = "Processing...";
        const stages = buildStagesFromDOM();
        const outputData = processImageData(cachedImageData, stages);
        outputCtx.putImageData(outputData, 0, 0);
        statusEl.textContent = "Done.";
      }

      function setImageSize(width, height) {
        for (const filter of Object.values(filters)) {
          if (!filter.uniformSetSize) {
            continue;
          }
          filter.uniformSetSize(width, height);
        }
      }

      function buildStagesFromDOM() {
        const rows = filtersContainer.querySelectorAll(".filter-row");
        const stages = [];
        for (const row of rows) {
          const id = row.dataset.filterId;
          const filter = id ? filters[id] : null;
          if (!filter) {
            continue;
          }
          const toggle = row.querySelector(".filter-toggle");
          if (toggle && !toggle.checked) {
            continue;
          }
          const inputs = row.querySelectorAll("input[data-uniform]");
          const uniforms = [];
          for (const input of inputs) {
            const name = input.dataset.uniform;
            const setter = filter.uniforms[name];
            if (!setter) {
              continue;
            }
            uniforms.push({ setter, value: Number(input.value) });
          }
          stages.push({ filter, uniforms });
        }
        return stages;
      }

      function runPipeline(tileBuffer, tileX, tileY, stages) {
        for (const stage of stages) {
          const filter = stage.filter;
          for (const uniform of stage.uniforms) {
            uniform.setter(uniform.value);
          }
          if (!filter.tileFn) {
            continue;
          }
          const view = filter.getTileView();
          view.set(tileBuffer);
          filter.tileFn(tileX, tileY);
          tileBuffer.set(view);
        }
      }

      filtersContainer.addEventListener("input", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLInputElement)) {
          return;
        }
        if (target.type !== "range") {
          return;
        }
        updateValueDisplay(target);
        updateLocationHash();
      });

      filtersContainer.addEventListener("change", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLInputElement)) {
          return;
        }
        if (target.type !== "checkbox") {
          return;
        }
        updateLocationHash();
      });

      filterMenu.addEventListener("click", (event) => {
        const button = event.target.closest("button[data-add-filter]");
        if (!button) {
          return;
        }
        const id = button.dataset.addFilter;
        const params = new URLSearchParams(location.hash.slice(1));
        const values = getTemplateDefaultValues(id);
        params.append(id, values.join(","));
        const next = params.toString();
        location.hash = next ? "#" + next : "";
        if (filterMenu.hidePopover) {
          filterMenu.hidePopover();
        }
      });

      window.addEventListener("hashchange", () => {
        updateFiltersFromLocationHash();
        renderPosterized();
      });

      filtersContainer.addEventListener("dragstart", (event) => {
        const handle = event.target.closest(".drag-handle");
        if (!handle) {
          event.preventDefault();
          return;
        }
        const row = handle.closest(".filter-row");
        if (!row) {
          return;
        }
        row.classList.add("dragging");
        event.dataTransfer.effectAllowed = "move";
        event.dataTransfer.setData("text/plain", row.dataset.filterId);
      });

      filtersContainer.addEventListener("dragend", (event) => {
        const row = event.target.closest(".filter-row");
        if (row) {
          row.classList.remove("dragging");
        }
      });

      filtersContainer.addEventListener("dragover", (event) => {
        event.preventDefault();
        const overRow = event.target.closest(".filter-row");
        const dragging = filtersContainer.querySelector(".dragging");
        if (!overRow || !dragging || overRow === dragging) {
          return;
        }
        const rect = overRow.getBoundingClientRect();
        const before = event.clientY < rect.top + rect.height / 2;
        if (before) {
          filtersContainer.insertBefore(dragging, overRow);
        } else {
          filtersContainer.insertBefore(dragging, overRow.nextSibling);
        }
      });

      filtersContainer.addEventListener("drop", (event) => {
        event.preventDefault();
        renderPosterized();
        updateLocationHash();
      });

      fileInput.addEventListener("change", async (event) => {
        const file = event.target.files && event.target.files[0];
        if (!file) {
          return;
        }
        try {
          await handleFile(file);
        } catch (err) {
          statusEl.textContent = "Error: " + err.message;
        }
      });

      (async () => {
        try {
          await loadWasm();
          updateFiltersFromLocationHash();
          statusEl.textContent = "Ready. Choose an image.";
        } catch (err) {
          statusEl.textContent = "Error: " + err.message;
        }
      })();
    </script>
  </body>
</html>
