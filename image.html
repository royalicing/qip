<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Image (WASM)</title>
    <style>
      :root {
        color-scheme: light;
      }
      body {
        font-family: system-ui, sans-serif;
        margin: 1lh;
        background: #111;
        color: white;
      }
      h1 {
        font-size: 20px;
        margin: 0 0 12px;
      }
      fieldset {
        border: none;
      }
      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
        margin-bottom: 16px;
      }
      .filters {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
      }
      .filter-row {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
        padding: 4px 0;
      }
      .drag-handle {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 18px;
        height: 18px;
        background: hsla(0, 0%, 100%, 0.1);
        color: white;
        font-size: 12px;
        cursor: grab;
        user-select: none;
      }
      .filter-row.dragging {
        opacity: 0.6;
      }
      .divider {
        color: #888;
      }
      .canvases {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
      }
      canvas {
        --color: oklab(50% 0 0);
        width: 100%;
        height: auto;
        border: 1px solid var(--color);
        background: var(--color);
      }
      .label {
        font-size: 12px;
        color: #555;
        margin: 6px 0 4px;
      }
      #status {
        margin-top: 12px;
        font-size: 12px;
        color: #555;
      }
      @media (max-width: 800px) {
        .canvases {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <h1>Image (WASM)</h1>
    <div class="controls">
      <input id="file" type="file" accept="image/*" />
    </div>

    <fieldset class="controls filters" id="filters">
      <label class="filter-row" data-filter-id="brightness">
        <span class="drag-handle" draggable="true" aria-hidden="true">≡</span>
        <input id="filter-brightness" type="checkbox" checked />
        <legend>Brightness</legend>
        <input
          id="brightness"
          type="range"
          min="-1"
          max="1"
          step="0.01"
          value="0"
          data-uniform="uniform_set_brightness"
          data-format="fixed2"
          data-value-id="brightness-value"
        />
        <span id="brightness-value">0.00</span>
      </label>
      <label class="filter-row" data-filter-id="contrast">
        <span class="drag-handle" draggable="true" aria-hidden="true">≡</span>
        <input id="filter-contrast" type="checkbox" checked />
        <span>Contrast</span>
        <input
          id="contrast"
          type="range"
          min="-1"
          max="1"
          step="0.01"
          value="0"
          data-uniform="uniform_set_contrast"
          data-format="fixed2"
          data-value-id="contrast-value"
        />
        <span id="contrast-value">0.00</span>
      </label>
      <label class="filter-row" data-filter-id="saturation">
        <span class="drag-handle" draggable="true" aria-hidden="true">≡</span>
        <input id="filter-saturation" type="checkbox" checked />
        <span>Saturation</span>
        <input
          id="saturation"
          type="range"
          min="-1"
          max="1"
          step="0.01"
          value="0"
          data-uniform="uniform_set_saturation"
          data-format="fixed2"
          data-value-id="saturation-value"
        />
        <span id="saturation-value">0.00</span>
      </label>
      <label class="filter-row" data-filter-id="hue-rotate">
        <span class="drag-handle" draggable="true" aria-hidden="true">≡</span>
        <input id="filter-hue-rotate" type="checkbox" checked />
        <span>Hue</span>
        <input
          id="hue-rotate"
          type="range"
          min="-180"
          max="180"
          step="1"
          value="0"
          data-uniform="uniform_set_hue_degrees"
          data-format="int"
          data-value-id="hue-rotate-value"
        />
        <span id="hue-rotate-value">0</span>
      </label>
      <label class="filter-row" data-filter-id="temperature">
        <span class="drag-handle" draggable="true" aria-hidden="true">≡</span>
        <input id="filter-temperature" type="checkbox" checked />
        <span>Temperature</span>
        <input
          id="temperature"
          type="range"
          min="-1"
          max="1"
          step="0.01"
          value="0"
          data-uniform="uniform_set_temperature"
          data-format="fixed2"
          data-value-id="temperature-value"
        />
        <span id="temperature-value">0.00</span>
      </label>
      <label class="filter-row" data-filter-id="tint">
        <span class="drag-handle" draggable="true" aria-hidden="true">≡</span>
        <input id="filter-tint" type="checkbox" checked />
        <span>Tint</span>
        <input
          id="tint"
          type="range"
          min="-1"
          max="1"
          step="0.01"
          value="0"
          data-uniform="uniform_set_tint"
          data-format="fixed2"
          data-value-id="tint-value"
        />
        <span id="tint-value">0.00</span>
      </label>
      <label class="filter-row" data-filter-id="posterize">
        <span class="drag-handle" draggable="true" aria-hidden="true">≡</span>
        <input id="filter-posterize" type="checkbox" />
        <span>Posterize</span>
        <input
          id="levels"
          type="range"
          min="2"
          max="32"
          value="8"
          data-uniform="uniform_set_levels_count"
          data-format="int"
          data-value-id="levels-value"
        />
        <span id="levels-value">8</span>
      </label>
      <label class="filter-row" data-filter-id="vignette">
        <span class="drag-handle" draggable="true" aria-hidden="true">≡</span>
        <input id="filter-vignette" type="checkbox" />
        <span>Vignette</span>
        <span class="divider">|</span>
        <span>Amount:</span>
        <input
          id="vignette-amount"
          type="range"
          min="0"
          max="1"
          step="0.01"
          value="0.35"
          data-uniform="uniform_set_amount"
          data-format="fixed2"
          data-value-id="vignette-amount-value"
        />
        <span id="vignette-amount-value">0.35</span>
        <span class="divider">|</span>
        <span>Midpoint:</span>
        <input
          id="vignette-midpoint"
          type="range"
          min="0"
          max="1"
          step="0.01"
          value="0.65"
          data-uniform="uniform_set_midpoint"
          data-format="fixed2"
          data-value-id="vignette-midpoint-value"
        />
        <span id="vignette-midpoint-value">0.65</span>
        <span class="divider">|</span>
        <span>Feather:</span>
        <input
          id="vignette-feather"
          type="range"
          min="0"
          max="1"
          step="0.01"
          value="0.85"
          data-uniform="uniform_set_feather"
          data-format="fixed2"
          data-value-id="vignette-feather-value"
        />
        <span id="vignette-feather-value">0.85</span>
      </label>
      <label class="filter-row" data-filter-id="black-and-white">
        <span class="drag-handle" draggable="true" aria-hidden="true">≡</span>
        <input id="filter-bw" type="checkbox" />
        <span>Black and white</span>
      </label>
      <label class="filter-row" data-filter-id="invert">
        <span class="drag-handle" draggable="true" aria-hidden="true">≡</span>
        <input id="filter-invert" type="checkbox" />
        <span>Invert</span>
      </label>
    </fieldset>

    <div class="canvases">
      <div>
        <div class="label">Original</div>
        <canvas id="source"></canvas>
      </div>
      <div>
        <div class="label">Result</div>
        <canvas id="output"></canvas>
      </div>
    </div>

    <div id="status">Loading WASM...</div>

    <script>
      const TILE = 64;
      const TILE_FLOATS = TILE * TILE * 4;
      const fileInput = document.getElementById("file");
      const filtersContainer = document.getElementById("filters");
      const statusEl = document.getElementById("status");
      const sourceCanvas = document.getElementById("source");
      const outputCanvas = document.getElementById("output");
      const sourceCtx = sourceCanvas.getContext("2d");
      const outputCtx = outputCanvas.getContext("2d");

      function filtersToURLSearchParams() {
        const q = new URLSearchParams();
        for (const key in filters) {
          const filter = filters[key];
          if (filter.toggle && !filter.toggle.checked) {
            continue;
          }
          if (filter.uniformInputs && filter.uniformInputs.length > 0) {
            const values = filter.uniformInputs.map((input) => input.value);
            q.set(filter.id, values.join(","));
            continue;
          }
          q.set(filter.id, "");
        }
        return q;
      }

      function updateFiltersFromLocationHash() {
        const params = new URLSearchParams(location.hash.slice(1));
        for (const key in filters) {
          const filter = filters[key];
          const enabled = params.has(filter.id);
          if (filter.toggle) {
            filter.toggle.checked = enabled;
          }
          if (enabled && filter.uniformInputs && filter.uniformInputs.length > 0) {
            const raw = params.get(filter.id);
            if (raw !== null) {
              const values = raw.split(",");
              for (let i = 0; i < filter.uniformInputs.length; i++) {
                if (values[i] !== undefined) {
                  filter.uniformInputs[i].value = values[i];
                }
              }
              applyUniformInputs(filter);
            }
          }
        }
      }

      function updateLocationHash() {
        const next = filtersToURLSearchParams().toString();
        const nextHash = next ? "#" + next : "";
        if (location.hash !== nextHash) {
          location.hash = nextHash;
        }
      }

      const filters = {
        brightness: { id: "brightness", path: "examples/rgba/brightness.wasm" },
        contrast: { id: "contrast", path: "examples/rgba/contrast.wasm" },
        saturation: { id: "saturation", path: "examples/rgba/saturation.wasm" },
        "hue-rotate": { id: "hue-rotate", path: "examples/rgba/hue-rotate.wasm" },
        temperature: { id: "temperature", path: "examples/rgba/temperature.wasm" },
        tint: { id: "tint", path: "examples/rgba/tint.wasm" },
        "black-and-white": {
          id: "black-and-white",
          path: "examples/rgba/black-and-white.wasm",
        },
        invert: { id: "invert", path: "examples/rgba/invert.wasm" },
        posterize: { id: "posterize", path: "examples/rgba/posterize.wasm" },
        vignette: { id: "vignette", path: "examples/rgba/vignette.wasm" },
      };

      function initFilterBindings() {
        for (const key in filters) {
          const filter = filters[key];
          filter.row = filtersContainer.querySelector(
            `[data-filter-id="${filter.id}"]`,
          );
          if (!filter.row) {
            continue;
          }
          filter.toggle = filter.row.querySelector('input[type="checkbox"]');
          filter.uniformInputs = Array.from(
            filter.row.querySelectorAll("input[data-uniform]"),
          );
          filter.uniforms = {};
        }
      }

      initFilterBindings();
      updateFiltersFromLocationHash();

      function exportedValue(exp) {
        if (typeof exp === "function") {
          return exp();
        }
        if (exp instanceof WebAssembly.Global) {
          return exp.value;
        }
        return exp;
      }

      function clampByte(value) {
        if (value < 0) return 0;
        if (value > 255) return 255;
        return value;
      }

      async function loadWasm() {
        await Promise.all(Object.values(filters).map(loadFilter));
      }

      async function loadFilter(filter) {
        const response = await fetch(filter.path);
        if (!response.ok) {
          throw new Error("Failed to load " + filter.path);
        }
        const bytes = await response.arrayBuffer();
        const { instance } = await WebAssembly.instantiate(bytes, {});
        const exports = instance.exports;
        filter.exports = exports;
        filter.memory = exports.memory;
        filter.inputPtr = exportedValue(exports.input_ptr);
        filter.tileFn = exports.tile_rgba_f32_64x64;
        filter.uniformSetSize = exports.uniform_set_width_and_height || null;
        if (filter.uniformInputs) {
          for (const input of filter.uniformInputs) {
            const name = input.dataset.uniform;
            if (name) {
              filter.uniforms[name] = exports[name] || null;
            }
          }
        }
        filter.getTileView = () =>
          new Float32Array(filter.memory.buffer, filter.inputPtr, TILE_FLOATS);
      }

      function formatValue(input, value) {
        const format = input.dataset.format;
        if (format === "int") {
          return String(Math.round(value));
        }
        if (format === "fixed2") {
          return Number(value).toFixed(2);
        }
        const step = input.step || "";
        const decimals = step.includes(".") ? step.split(".")[1].length : 0;
        return decimals > 0 ? Number(value).toFixed(decimals) : String(value);
      }

      function applyUniformInput(input) {
        const row = input.closest(".filter-row");
        if (!row) {
          return;
        }
        const filter = filters[row.dataset.filterId];
        if (!filter) {
          return;
        }
        const uniformName = input.dataset.uniform;
        if (!uniformName) {
          return;
        }
        const value = Number(input.value);
        const valueId = input.dataset.valueId;
        if (valueId) {
          const valueEl = document.getElementById(valueId);
          if (valueEl) {
            valueEl.textContent = formatValue(input, value);
          }
        }
        const setter = filter.uniforms ? filter.uniforms[uniformName] : null;
        if (setter) {
          setter(value);
        }
      }

      function applyUniformInputs(filter) {
        if (!filter.uniformInputs) {
          return;
        }
        for (const input of filter.uniformInputs) {
          applyUniformInput(input);
        }
      }

      function processImageData(imageData) {
        const { data, width, height } = imageData;
        const out = new Uint8ClampedArray(data.length);
        const tileBuffer = new Float32Array(TILE_FLOATS);

        for (let y = 0; y < height; y += TILE) {
          for (let x = 0; x < width; x += TILE) {
            tileBuffer.fill(0);
            const tileW = Math.min(TILE, width - x);
            const tileH = Math.min(TILE, height - y);

            for (let ty = 0; ty < tileH; ty++) {
              for (let tx = 0; tx < tileW; tx++) {
                const srcIndex = ((y + ty) * width + (x + tx)) * 4;
                const tileIndex = (ty * TILE + tx) * 4;
                tileBuffer[tileIndex] = data[srcIndex] / 255;
                tileBuffer[tileIndex + 1] = data[srcIndex + 1] / 255;
                tileBuffer[tileIndex + 2] = data[srcIndex + 2] / 255;
                tileBuffer[tileIndex + 3] = data[srcIndex + 3] / 255;
              }
            }

            runPipeline(tileBuffer, x, y);

            for (let ty = 0; ty < tileH; ty++) {
              for (let tx = 0; tx < tileW; tx++) {
                const dstIndex = ((y + ty) * width + (x + tx)) * 4;
                const tileIndex = (ty * TILE + tx) * 4;
                out[dstIndex] = clampByte(
                  Math.round(tileBuffer[tileIndex] * 255),
                );
                out[dstIndex + 1] = clampByte(
                  Math.round(tileBuffer[tileIndex + 1] * 255),
                );
                out[dstIndex + 2] = clampByte(
                  Math.round(tileBuffer[tileIndex + 2] * 255),
                );
                out[dstIndex + 3] = clampByte(
                  Math.round(tileBuffer[tileIndex + 3] * 255),
                );
              }
            }
          }
        }

        return new ImageData(out, width, height);
      }

      let cachedImageData = null;

      async function handleFile(file) {
        statusEl.textContent = "Decoding image...";
        const bitmap = await createImageBitmap(file);
        sourceCanvas.width = bitmap.width;
        sourceCanvas.height = bitmap.height;
        outputCanvas.width = bitmap.width;
        outputCanvas.height = bitmap.height;
        sourceCtx.drawImage(bitmap, 0, 0);

        cachedImageData = sourceCtx.getImageData(
          0,
          0,
          bitmap.width,
          bitmap.height,
        );
        setImageSize(bitmap.width, bitmap.height);
        renderPosterized();
      }

      function renderPosterized() {
        if (!cachedImageData) {
          return;
        }
        statusEl.textContent = "Processing...";
        const outputData = processImageData(cachedImageData);
        outputCtx.putImageData(outputData, 0, 0);
        statusEl.textContent = "Done.";
      }

      function setImageSize(width, height) {
        for (const filter of Object.values(filters)) {
          if (!filter.uniformSetSize) {
            continue;
          }
          filter.uniformSetSize(width, height);
        }
      }

      function runPipeline(tileBuffer, tileX, tileY) {
        for (const filter of getOrderedFilters()) {
          if (!filter.toggle.checked) {
            continue;
          }
          if (!filter.tileFn) {
            continue;
          }
          const view = filter.getTileView();
          view.set(tileBuffer);
          filter.tileFn(tileX, tileY);
          tileBuffer.set(view);
        }
      }

      function getOrderedFilters() {
        return Array.from(filtersContainer.children)
          .map((row) => filters[row.dataset.filterId])
          .filter(Boolean);
      }

      filtersContainer.addEventListener("input", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLInputElement)) {
          return;
        }
        if (target.type !== "range") {
          return;
        }
        applyUniformInput(target);
        renderPosterized();
        updateLocationHash();
      });

      filtersContainer.addEventListener("change", (event) => {
        const target = event.target;
        if (!(target instanceof HTMLInputElement)) {
          return;
        }
        if (target.type !== "checkbox") {
          return;
        }
        renderPosterized();
        updateLocationHash();
      });

      window.addEventListener("hashchange", () => {
        updateFiltersFromLocationHash();
        renderPosterized();
      });

      filtersContainer.addEventListener("dragstart", (event) => {
        const handle = event.target.closest(".drag-handle");
        if (!handle) {
          event.preventDefault();
          return;
        }
        const row = handle.closest(".filter-row");
        if (!row) {
          return;
        }
        row.classList.add("dragging");
        event.dataTransfer.effectAllowed = "move";
        event.dataTransfer.setData("text/plain", row.dataset.filterId);
      });

      filtersContainer.addEventListener("dragend", (event) => {
        const row = event.target.closest(".filter-row");
        if (row) {
          row.classList.remove("dragging");
        }
      });

      filtersContainer.addEventListener("dragover", (event) => {
        event.preventDefault();
        const overRow = event.target.closest(".filter-row");
        const dragging = filtersContainer.querySelector(".dragging");
        if (!overRow || !dragging || overRow === dragging) {
          return;
        }
        const rect = overRow.getBoundingClientRect();
        const before = event.clientY < rect.top + rect.height / 2;
        if (before) {
          filtersContainer.insertBefore(dragging, overRow);
        } else {
          filtersContainer.insertBefore(dragging, overRow.nextSibling);
        }
      });

      filtersContainer.addEventListener("drop", (event) => {
        event.preventDefault();
        renderPosterized();
        updateLocationHash();
      });

      fileInput.addEventListener("change", async (event) => {
        const file = event.target.files && event.target.files[0];
        if (!file) {
          return;
        }
        try {
          await handleFile(file);
        } catch (err) {
          statusEl.textContent = "Error: " + err.message;
        }
      });

      (async () => {
        try {
          await loadWasm();
          for (const key in filters) {
            applyUniformInputs(filters[key]);
          }
          statusEl.textContent = "Ready. Choose an image.";
        } catch (err) {
          statusEl.textContent = "Error: " + err.message;
        }
      })();
    </script>
  </body>
</html>
